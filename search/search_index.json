{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Strawberry integration with Django</p> <p>WHAT: A toolset for GraphQL schema generation from Django models.</p> <p>WHY: To build better web apps more quickly and with less code.</p> <p>HOW: By providing django-specific methods for using the strawberry GraphQL library.</p> <p> </p>"},{"location":"#supported-features","title":"Supported features","text":"<ul> <li> GraphQL type generation from models</li> <li> Filtering, pagination and ordering</li> <li> Basic create, retrieve, update and delete (CRUD) types and mutations</li> <li> Basic Django auth support, current user query, login and logout mutations</li> <li> Django sync and async views</li> <li> Permission extension using django's permissioning system</li> <li> Relay support with automatic resolvers generation</li> <li> Query optimization to improve performance and avoid common pitfalls (e.g n+1)</li> <li> Debug Toolbar integration with graphiql to display metrics like SQL queries</li> <li> Unit test integration</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>Check out the quick start for all the basics, then the example app for a slightly more complete setup )</p>"},{"location":"community-projects/","title":"Community Projects","text":"<p>Those are some community maintained projects worth mentioning:</p> Project Description  strawberry-django-auth  Authentication System for Django using Strawberry.  strawberry-django-extras  JWT Authentication, Input validation and permissions, mutation hooks and deeply nested CUD mutations <p>If you want your integration to be listed here, send us a Pull Request</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We use poetry to manage dependencies, to get started follow these steps:</p> <pre><code>git clone https://github.com/strawberry-graphql/strawberry-django.git\ncd strawberry_django\npoetry install\npoetry run pytest\n</code></pre> <p>This will install all the dependencies (including the dev ones) and run the tests.</p> <p>If the tests fail with <code>SpatiaLite requires SQLite to be configured to allow extension loading</code> error, it means that your python interpreter is not built with <code>--enable-loadable-sqlite-extensions</code> flag. For example, if you are using pyenv, it can be fixed like this:</p> <p><code>PYTHON_CONFIGURE_OPTS=\"--enable-loadable-sqlite-extensions\" pyenv install 3.12.0</code></p>"},{"location":"contributing/#pre-commit","title":"Pre commit","text":"<p>We have a configuration for pre-commit, to add the hook run the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#docs-setup-and-local-server","title":"Docs setup and local server","text":"<p>We use Material for MkDocs, you can read the documentation here</p> <pre><code>make serve-docs\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#how-to-access-django-request-object-in-resolvers","title":"How to access Django request object in resolvers?","text":"<p>The request object is accessible via the <code>get_request</code> method.</p> <pre><code>from strawberry_django.auth.utils import get_request\n\ndef resolver(root, info: Info):\n    request = get_request(info)\n</code></pre>"},{"location":"faq/#how-to-access-the-current-user-object-in-resolvers","title":"How to access the current user object in resolvers?","text":"<p>The current user object is accessible via the <code>get_current_user</code> method.</p> <pre><code>from strawberry_django.auth.queries import get_current_user\n\ndef resolver(root, info: Info):\n    current_user = get_current_user(info)\n</code></pre>"},{"location":"faq/#autocompletion-with-editors","title":"Autocompletion with editors","text":"<p>Some editors like VSCode may not be able to resolve symbols and types without explicit <code>strawberry.django</code> import. Adding following line to code fixes that problem.</p> <pre><code>import strawberry.django\n</code></pre>"},{"location":"faq/#example-project","title":"Example project?","text":"<p>See complete Django project from github repository folder examples/django.</p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>In this Quick-Start, we will:</p> <ul> <li>Set up a basic pair of models with a relation between them.</li> <li>Add them to a graphql schema and serve the graph API.</li> <li>Query the graph API for model contents.</li> </ul> <p>For a more advanced example of a similar setup including a set of mutations and more queries, please check the example app.</p>"},{"location":"quick-start/#installation","title":"Installation","text":"<pre><code>poetry add strawberry-graphql-django\npoetry add django-choices-field  # Not required but recommended\n</code></pre> <p>(Not using poetry yet? <code>pip install strawberry-graphql-django</code> works fine too.)</p>"},{"location":"quick-start/#define-your-application-models","title":"Define your application models","text":"<p>We'll build an example database of fruit and their colours.</p> <p>Tip</p> <p>You'll notice that for <code>Fruit.category</code>, we use <code>TextChoicesField</code> instead of <code>TextField(choices=...)</code>. This allows strawberry-django to automatically use an enum in the graphQL schema, instead of a string which would be the default behaviour for TextField.</p> <p>See the choices-field integration for more information.</p> models.py<pre><code>from django.db import models\nfrom django_choices_field import TextChoicesField\n\nclass FruitCategory(models.TextChoices):\n    CITRUS = \"citrus\", \"Citrus\"\n    BERRY = \"berry\", \"Berry\"\n\nclass Fruit(models.Model):\n    \"\"\"A tasty treat\"\"\"\n\n    name = models.CharField(max_length=20, help_text=\"The name of the fruit variety\")\n    category = TextChoicesField(choices_enum=FruitCategory, help_text=\"The category of the fruit\")\n    color = models.ForeignKey(\n        \"Color\",\n        on_delete=models.CASCADE,\n        related_name=\"fruits\",\n        blank=True,\n        null=True,\n        help_text=\"The color of this kind of fruit\",\n    )\n\nclass Color(models.Model):\n    \"\"\"The hue of your tasty treat\"\"\"\n\n    name = models.CharField(\n        max_length=20,\n        help_text=\"The color name\",\n    )\n</code></pre> <p>You'll need to make migrations then migrate:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> <p>Now use the django shell, the admin, the loaddata command or whatever tool you like to load some fruits and colors. I've loaded a red strawberry (predictable, right?!) ready for later.</p>"},{"location":"quick-start/#define-types","title":"Define types","text":"<p>Before creating queries, you have to define a <code>type</code> for each model. A <code>type</code> is a fundamental unit of the schema which describes the shape of the data that can be queried from the GraphQL server. Types can represent scalar values (like String, Int, Boolean, Float, and ID), enums, or complex objects that consist of many fields.</p> <p>Tip</p> <p>A key feature of <code>strawberry-graphql-django</code> is that it provides helpers to create types from django models, by automatically inferring types (and even documentation!!) from the model fields.</p> <p>See the fields guide for more information.</p> types.py<pre><code>import strawberry_django\nfrom strawberry import auto\n\nfrom . import models\n\n@strawberry_django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    category: auto\n    color: \"Color\"  # Strawberry will understand that this refers to the \"Color\" type that's defined below\n\n@strawberry_django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: list[Fruit] # This tells strawberry about the ForeignKey to the Fruit model and how to represent the Fruit instances on that relation\n</code></pre>"},{"location":"quick-start/#build-the-queries-and-schema","title":"Build the queries and schema","text":"<p>Next we want to assemble the schema from its building block types.</p> <p>Warning</p> <p>You'll notice a familiar statement, <code>fruits: list[Fruit]</code>. We already used this statement in the previous step in <code>types.py</code>. Seeing it twice can be a point of confusion when you're first getting to grips with graph and strawberry.</p> <p>The purpose here is similar but subtly different. Previously, the syntax defined that it was possible to make a query that traverses within the graph, from a Color to a list of Fruits. Here, the usage defines a root query (a bit like an entrypoint into the graph).</p> <p>Tip</p> <p>We add the <code>DjangoOptimizerExtension</code> here. Don't worry about why for now, but you're almost certain to want it.</p> <p>See the optimizer guide for more information.</p> schema.py<pre><code>import strawberry\nfrom strawberry_django.optimizer import DjangoOptimizerExtension\n\nfrom .types import Fruit\n\n@strawberry.type\nclass Query:\n    fruits: list[Fruit] = strawberry_django.field()\n\nschema = strawberry.Schema(\n    query=Query,\n    extensions=[\n        DjangoOptimizerExtension,\n    ],\n)\n</code></pre>"},{"location":"quick-start/#serving-the-api","title":"Serving the API","text":"<p>Now we're showing off. This isn't enabled by default, since existing django applications will likely have model docstrings and help text that aren't user-oriented. But if you're starting clean (or overhauling existing dosctrings and helptext), setting up the following is super useful for your API users.</p> <p>If you don't set these true, you can always provide user-oriented descriptions. See the</p> settings.py<pre><code>STRAWBERRY_DJANGO = {\n    \"FIELD_DESCRIPTION_FROM_HELP_TEXT\": True,\n    \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\": True,\n}\n</code></pre> urls.py<pre><code>from django.urls import include, path\nfrom strawberry.django.views import AsyncGraphQLView\n\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', AsyncGraphQLView.as_view(schema=schema)),\n]\n</code></pre> <p>This generates following schema:</p> schema.graphql<pre><code>enum FruitCategory {\n  CITRUS\n  BERRY\n}\n\n\"\"\"\nA tasty treat\n\"\"\"\ntype Fruit {\n  id: ID!\n  name: String!\n  category: FruitCategory!\n  color: Color\n}\n\ntype Color {\n  id: ID!\n  \"\"\"\n  field description\n  \"\"\"\n  name: String!\n  fruits: [Fruit!]\n}\n\ntype Query {\n  fruits: [Fruit!]!\n}\n</code></pre>"},{"location":"quick-start/#using-the-api","title":"Using the API","text":"<p>Start your server with:</p> <pre><code>python manage.py runserver\n</code></pre> <p>Then visit localhost:8000/graphql in your browser. You should see the graphql explorer being served by django. Using the interactive query tool, you can query for the fruits you added earlier:</p>"},{"location":"quick-start/#next-steps","title":"Next steps","text":"<ol> <li>Defining more Django Types</li> <li>Define Fields inside those Types</li> <li>Serve your API using ASGI or WSGI</li> <li>Define filters for your fields</li> <li>Define orderings for your fields</li> <li>Define pagination for your fields</li> <li>Define queries for your schema</li> <li>Define mutations for your schema</li> <li>Define subscriptions for your schema</li> <li>Enable the Query Optimizer extension for performance improvement</li> <li>Use the relay integration for advanced pagination and model refetching</li> <li>Protect your fields using the Permission Extension</li> <li>Write unit tests for your schema</li> </ol>"},{"location":"guide/authentication/","title":"Authentication","text":"<p>Warning</p> <p>This solution is enough for web browsers, but will not work for clients that doesn't have a way to store cookies in it (e.g. mobile apps). For those it is recommended to use token authentication methods. JWT can be used with strawberry-django-jwt lib.</p> <p><code>strawberry_django</code> provides mutations to get authentication going right away. The <code>auth.register</code> mutation performs password validation using Django's <code>validate_password</code> method.</p> types.py<pre><code>import strawberry_django\nfrom strawberry import auto\nfrom django.contrib.auth import get_user_model\n\n@strawberry_django.type(get_user_model())\nclass User:\n    username: auto\n    email: auto\n\n@strawberry_django.input(get_user_model())\nclass UserInput:\n    username: auto\n    password: auto\n</code></pre> schema.py<pre><code>import strawberry\nimport strawberry_django\nfrom .types import User, UserInput\n\n@strawberry.type\nclass Query:\n    me: User = strawberry_django.auth.current_user()\n\n@strawberry.type\nclass Mutation:\n    login: User = strawberry_django.auth.login()\n    logout = strawberry_django.auth.logout()\n    register: User = strawberry_django.auth.register(UserInput)\n</code></pre>"},{"location":"guide/export-schema/","title":"Export Schema","text":"<p>Info</p> <p>The <code>export_schema</code> management command provided here is specifically designed for use with <code>strawberry_django</code>. The default Strawberry export command won't work with <code>strawberry_django</code> schemas because <code>strawberry_django</code> extends the base functionality of Strawberry to integrate with Django models and queries. This command ensures proper schema export functionality.</p> <p>The <code>export_schema</code> management command allows you to export a GraphQL schema defined using the <code>strawberry_django</code> library. This command converts the schema definition to GraphQL schema definition language (SDL), which can then be saved to a file or printed to the console.</p>"},{"location":"guide/export-schema/#usage","title":"Usage","text":"<p>To use the <code>export_schema</code> command, you need to specify the schema location(e.g., myapp.schema). Optionally, you can provide a file path to save the schema. If no path is provided, the schema will be printed to the console.</p> <pre><code>python manage.py export_schema &lt;schema_location&gt; --path &lt;output_path&gt;\n</code></pre>"},{"location":"guide/export-schema/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;schema_location&gt;</code>: The location of the schema module. This should be a dot-separated Python path (e.g., myapp.schema). For example, if your schema is located in the <code>schemas</code> directory in the <code>myapp</code> django app, you would use <code>myapp.schemas</code>.</li> </ul>"},{"location":"guide/export-schema/#options","title":"Options","text":"<ul> <li><code>--path &lt;output_path&gt;</code>: An optional argument specifying the file path where the schema should be saved. If not provided, the schema will be printed to standard output.</li> </ul>"},{"location":"guide/export-schema/#example","title":"Example","text":"<p>Here's an example of how to use the export_schema command:</p> <pre><code>python manage.py export_schema myapp.schema --path=output/schema.graphql\n</code></pre> <p>In this example, the schema located at <code>myapp.schema</code> will be exported to the file <code>output/schema.graphql</code>.</p>"},{"location":"guide/fields/","title":"Defining Fields","text":"<p>Tip</p> <p>It is highly recommended to enable the Query Optimizer Extension for improved performance and avoid some common pitfalls (e.g. the <code>n+1</code> issue)</p> <p>Fields can be defined manually or <code>auto</code> type can be used for automatic type resolution. All basic field types and relation fields are supported out of the box. If you use a library that defines a custom field you will need to define an equivalent type such as <code>str</code>, <code>float</code>, <code>bool</code>, <code>int</code> or <code>id</code>.</p> types.py<pre><code>import strawberry_django\nfrom strawberry import auto\n\n@strawberry_django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n\n# equivalent type, inferred by `strawberry`\n\n@strawberry_django.type(models.Fruit)\nclass Fruit2:\n    id: strawberry.ID\n    name: str\n</code></pre> <p>Tip</p> <p>For choices using Django's TextChoices/IntegerChoices it is recommented using the django-choices-field integration enum handling.</p>"},{"location":"guide/fields/#relationships","title":"Relationships","text":"<p>All one-to-one, one-to-many, many-to-one and many-to-many relationship types are supported, and the many-to-many relation is described using the <code>typing.List</code> annotation. The default resolver of <code>strawberry_django.fields()</code> resolves the relationship based on given type information.</p> types.py<pre><code>from typing import List\n\n@strawberry_django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    color: \"Color\"\n\n\n@strawberry_django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: List[Fruit]\n</code></pre> <p>Note that all relations can naturally trigger the n+1 problem. To avoid that, you can either enable the Optimizer Extension which will automatically solve some general issues for you, or even use Data Loaders for more complex situations.</p>"},{"location":"guide/fields/#field-customization","title":"Field customization","text":"<p>All Django types are encoded using the <code>strawberry_django.field()</code> field type by default. Fields can be customized with various parameters.</p> types.py<pre><code>@strawberry_django.type(models.Color)\nclass Color:\n    another_name: auto = strawberry_django.field(field_name='name')\n    internal_name: auto = strawberry_django.field(\n        name='fruits',\n        field_name='fruit_set',\n        filters=FruitFilter,\n        order=FruitOrder,\n        pagination=True,\n        description=\"A list of fruits with this color\"\n    )\n</code></pre>"},{"location":"guide/fields/#defining-types-for-auto-fields","title":"Defining types for auto fields","text":"<p>When using <code>strawberry.auto</code> to resolve a field's type, Strawberry Django uses a dict that maps each django field field type to its proper type. e.g.:</p> <pre><code>{\n    models.CharField: str,\n    models.IntegerField: int,\n    ...,\n}\n</code></pre> <p>If you are using a custom django field that is not part of the default library, or you want to use a different type for a field, you can do that by overriding its value in the map, like:</p> <pre><code>from typing import NewType\n\nfrom django.db import models\nimport strawberry\nimport strawberry_django\nfrom strawberry_django.fields.types import field_type_map\n\nSlug = strawberry.scalar(\n    NewType(\"Slug\", str),\n    serialize=lambda v: v,\n    parse_value=lambda v: v,\n)\n\n@strawberry_django.type\nclass MyCustomFileType:\n    ...\n\nfield_type_map.update({\n    models.SlugField: Slug,\n    models.FileField: MyCustomFileType,\n})\n</code></pre>"},{"location":"guide/fields/#including-excluding-django-model-fields-by-name","title":"Including / excluding Django model fields by name","text":"<p>Warning</p> <p>These new keywords should be used with caution, as they may inadvertently lead to exposure of unwanted data. Especially with <code>fields=\"__all__\"</code> or <code>exclude</code>, sensitive model attributes may be included and made available in the schema without your awareness.</p> <p><code>strawberry_django.type</code> includes two optional keyword fields to help you populate fields from the Django model, <code>fields</code> and <code>exclude</code>.</p> <p>Valid values for <code>fields</code> are:</p> <ul> <li><code>__all__</code> to assign <code>strawberry.auto</code> as the field type for all model fields.</li> <li><code>[&lt;List of field names&gt;]</code> to assign <code>strawberry.auto</code> as the field type for the enumerated fields. These can be combined with manual type annotations if needed.</li> </ul> All Fields<pre><code>@strawberry_django.type(models.Fruit, fields=\"__all__\")\nclass FruitType:\n    pass\n</code></pre> Enumerated Fields<pre><code>@strawberry_django.type(models.Fruit, fields=[\"name\", \"color\"])\nclass FruitType:\n    pass\n</code></pre> Overriden Fields<pre><code>@strawberry_django.type(models.Fruit, fields=[\"color\"])\nclass FruitType:\n    name: str\n</code></pre> <p>Valid values for <code>exclude</code> are:</p> <ul> <li><code>[&lt;List of field names&gt;]</code> to exclude from the fields list. All other Django model fields will included and have <code>strawberry.auto</code> as the field type. These can also be overriden if another field type should be assigned. An empty list is ignored.</li> </ul> Exclude Fields<pre><code>@strawberry_django.type(models.Fruit, exclude=[\"name\"])\nclass FruitType:\n    pass\n</code></pre> Overriden Exclude Fields<pre><code>@strawberry_django.type(models.Fruit, exclude=[\"name\"])\nclass FruitType:\n    color: int\n</code></pre> <p>Note that <code>fields</code> has precedence over <code>exclude</code>, so if both are provided, then <code>exclude</code> is ignored.</p>"},{"location":"guide/fields/#overriding-the-field-class-advanced","title":"Overriding the field class (advanced)","text":"<p>If in your project, you want to change/add some of the standard <code>strawberry_django.field()</code> behaviour, it is possible to use your own custom field class when decorating a <code>strawberry_django.type</code> with the <code>field_cls</code> argument, e.g.</p> types.py<pre><code>class CustomStrawberryDjangoField(StrawberryDjangoField):\n    \"\"\"Your custom behaviour goes here.\"\"\"\n\n@strawberry_django.type(User, field_cls=CustomStrawberryDjangoField)\nclass UserType:\n    # Each of these fields will be an instance of `CustomStrawberryDjangoField`.\n    id: int\n    name: auto\n\n\n@strawberry.type\nclass UserQuery:\n    # You can directly create your custom field class on a plain strawberry type\n    user: UserType = CustomStrawberryDjangoField()\n</code></pre> <p>In this example, each of the fields of the <code>UserType</code> will be automatically created by <code>CustomStrawberryDjangoField</code>, which may implement anything from custom pagination of relationships to altering the field permissions.</p>"},{"location":"guide/filters/","title":"Filtering","text":"<p>It is possible to define filters for Django types, which will be converted into <code>.filter(...)</code> queries for the ORM:</p> types.py<pre><code>import strawberry_django\nfrom strawberry import auto\n\n@strawberry_django.filter(models.Fruit)\nclass FruitFilter:\n    id: auto\n    name: auto\n\n@strawberry_django.type(models.Fruit, filters=FruitFilter)\nclass Fruit:\n    ...\n</code></pre> <p>Tip</p> <p>In most cases filter fields should have <code>Optional</code> annotations and default value <code>strawberry.UNSET</code> like so: <code>foo: Optional[SomeType] = strawberry.UNSET</code> Above <code>auto</code> annotation is wrapped in <code>Optional</code> automatically. <code>UNSET</code> is automatically used for fields without <code>field</code> or with <code>strawberry_django.filter_field</code>.</p> <p>The code above would generate following schema:</p> schema.graphql<pre><code>input FruitFilter {\n  id: ID\n  name: String\n  AND: FruitFilter\n  OR: FruitFilter\n  NOT: FruitFilter\n  DISTINCT: Boolean\n}\n</code></pre> <p>Tip</p> <p>If you are using the relay integration and working with types inheriting from <code>relay.Node</code> and <code>GlobalID</code> for identifying objects, you might want to set <code>MAP_AUTO_ID_AS_GLOBAL_ID=True</code> in your strawberry django settings to make sure <code>auto</code> fields gets mapped to <code>GlobalID</code> on types and filters.</p>"},{"location":"guide/filters/#and-or-not-distinct","title":"AND, OR, NOT, DISTINCT ...","text":"<p>To every filter <code>AND</code>, <code>OR</code>, <code>NOT</code> &amp; <code>DISTINCT</code> fields are added to allow more complex filtering</p> <pre><code>{\n  fruits(\n    filters: {\n      name: \"kebab\"\n      OR: {\n        name: \"raspberry\"\n      }\n    }\n  ) { ... }\n}\n</code></pre>"},{"location":"guide/filters/#lookups","title":"Lookups","text":"<p>Lookups can be added to all fields with <code>lookups=True</code>, which will add more options to resolve each type. For example:</p> types.py<pre><code>@strawberry_django.filter(models.Fruit, lookups=True)\nclass FruitFilter:\n    id: auto\n    name: auto\n</code></pre> <p>The code above would generate the following schema:</p> schema.graphql<pre><code>input IDBaseFilterLookup {\n  exact: ID\n  isNull: Boolean\n  inList: [String!]\n}\n\ninput StrFilterLookup {\n  exact: ID\n  isNull: Boolean\n  inList: [String!]\n  iExact: String\n  contains: String\n  iContains: String\n  startsWith: String\n  iStartsWith: String\n  endsWith: String\n  iEndsWith: String\n  regex: String\n  iRegex: String\n}\n\ninput FruitFilter {\n  id: IDFilterLookup\n  name: StrFilterLookup\n  AND: FruitFilter\n  OR: FruitFilter\n  NOT: FruitFilter\n  DISTINCT: Boolean\n}\n</code></pre> <p>Single-field lookup can be annotated with the <code>FilterLookup</code> generic type.</p> types.py<pre><code>from strawberry_django import FilterLookup\n\n@strawberry_django.filter(models.Fruit)\nclass FruitFilter:\n    name: FilterLookup[str]\n</code></pre>"},{"location":"guide/filters/#filtering-over-relationships","title":"Filtering over relationships","text":"types.py<pre><code>@strawberry_django.filter(models.Color)\nclass ColorFilter:\n    id: auto\n    name: auto\n\n@strawberry_django.filter(models.Fruit)\nclass FruitFilter:\n    id: auto\n    name: auto\n    color: ColorFilter | None\n</code></pre> <p>The code above would generate following schema:</p> schema.graphql<pre><code>input ColorFilter {\n  id: ID\n  name: String\n  AND: ColorFilter\n  OR: ColorFilter\n  NOT: ColorFilter\n}\n\ninput FruitFilter {\n  id: ID\n  name: String\n  color: ColorFilter\n  AND: FruitFilter\n  OR: FruitFilter\n  NOT: FruitFilter\n}\n</code></pre>"},{"location":"guide/filters/#custom-filter-methods","title":"Custom filter methods","text":"<p>You can define custom filter method by defining your own resolver.</p> types.py<pre><code>@strawberry_django.filter(models.Fruit)\nclass FruitFilter:\n    name: auto\n    last_name: auto\n\n    @strawberry_django.filter_field\n    def simple(self, value: str, prefix) -&gt; Q:\n        return Q(**{f\"{prefix}name\": value})\n\n    @strawberry_django.filter_field\n    def full_name(\n        self,\n        queryset: QuerySet,\n        value: str,\n        prefix: str\n    ) -&gt; tuple[QuerySet, Q]:\n        queryset = queryset.alias(\n            _fullname=Concat(\n                f\"{prefix}name\", Value(\" \"), f\"{prefix}last_name\"\n            )\n        )\n        return queryset, Q(**{\"_fullname\": value})\n\n    @strawberry_django.filter_field\n    def full_name_lookups(\n        self,\n        info: Info,\n        queryset: QuerySet,\n        value: strawberry_django.FilterLookup[str],\n        prefix: str\n    ) -&gt; tuple[QuerySet, Q]:\n        queryset = queryset.alias(\n            _fullname=Concat(\n                f\"{prefix}name\", Value(\" \"), f\"{prefix}last_name\"\n            )\n        )\n        return strawberry_django.process_filters(\n            filters=value,\n            queryset=queryset,\n            info=info,\n            prefix=f\"{prefix}_fullname\"\n        )\n</code></pre> <p>Warning</p> <p>It is discouraged to use <code>queryset.filter()</code> directly. When using more complex filtering via <code>NOT</code>, <code>OR</code> &amp; <code>AND</code> this might lead to undesired behaviour.</p> <p>Tip</p> <p>The code above generates the following schema:</p> schema.graphql<pre><code>input FruitFilter {\n  name: String\n  lastName: String\n  simple: str\n  fullName: str\n  fullNameLookups: StrFilterLookup\n}\n</code></pre>"},{"location":"guide/filters/#process_filters","title":"process_filters","text":"<p>As seen above <code>strawberry_django.process_filters</code> function is exposed and can be reused in custom methods. Above it's used to resolve fields lookups</p>"},{"location":"guide/filters/#null-values","title":"null values","text":"<p>By default <code>null</code> value is ignored for all filters &amp; lookups. This applies to custom filter methods as well. Those won't even be called (you don't have to check for <code>None</code>). This can be modified using <code>strawberry_django.filter_field(filter_none=True)</code></p> <p>This also means that built in <code>exact</code> &amp; <code>iExact</code> lookups cannot be used to filter for <code>None</code> and <code>isNull</code> have to be used explicitly.</p>"},{"location":"guide/filters/#value-resolution","title":"value resolution","text":"<ul> <li><code>value</code> parameter of type <code>relay.GlobalID</code> is resolved to its <code>node_id</code> attribute</li> <li><code>value</code> parameter of type <code>Enum</code> is resolved to is's value</li> <li>above types are converted in <code>lists</code> as well</li> </ul> <p>resolution can modified via <code>strawberry_django.filter_field(resolve_value=...)</code></p> <ul> <li>True - always resolve</li> <li>False - never resolve</li> <li>UNSET (default) - resolves for filters without custom method only</li> </ul>"},{"location":"guide/filters/#resolver-arguments","title":"Resolver arguments","text":"<ul> <li><code>prefix</code> - represents the current path or position</li> <li>Required</li> <li>Important for nested filtering</li> <li>In code bellow custom filter <code>name</code> ends up filtering <code>Fruit</code> instead of <code>Color</code> without applying <code>prefix</code></li> </ul> Why prefix?<pre><code>@strawberry_django.filter(models.Fruit)\nclass FruitFilter:\n    name: auto\n    color: ColorFilter | None\n\n@strawberry_django.filter(models.Color)\nclass ColorFilter:\n    @strawberry_django.filter_field\n    def name(self, value: str, prefix: str):\n        # prefix is \"fruit_set__\" if unused root object is filtered instead\n        if value:\n            return Q(name=value)\n        return Q()\n</code></pre> <pre><code>{\n  fruits( filters: {color: name: \"blue\"} ) { ... }\n}\n</code></pre> <ul> <li><code>value</code> - represents graphql field type</li> <li>Required, but forbidden for default <code>filter</code> method</li> <li>must be annotated</li> <li>used instead of field's return type</li> <li><code>queryset</code> - can be used for more complex filtering</li> <li>Optional, but Required for default <code>filter</code> method</li> <li>usually used to <code>annotate</code> <code>QuerySet</code></li> </ul>"},{"location":"guide/filters/#resolver-return","title":"Resolver return","text":"<p>For custom field methods two return values are supported</p> <ul> <li>django's <code>Q</code> object</li> <li>tuple with <code>QuerySet</code> and django's <code>Q</code> object -&gt; <code>tuple[QuerySet, Q]</code></li> </ul> <p>For default <code>filter</code> method only second variant is supported.</p>"},{"location":"guide/filters/#what-about-nulls","title":"What about nulls?","text":"<p>By default <code>null</code> values are ignored. This can be toggled as such <code>@strawberry_django.filter_field(filter_none=True)</code></p>"},{"location":"guide/filters/#overriding-the-default-filter-method","title":"Overriding the default <code>filter</code> method","text":"<p>Works similar to field filter method, but:</p> <ul> <li>is responsible for resolution of filtering for entire object</li> <li>must be named <code>filter</code></li> <li>argument <code>queryset</code> is Required</li> <li>argument <code>value</code> is Forbidden</li> </ul> types.py<pre><code>@strawberry_django.filter(models.Fruit)\nclass FruitFilter:\n    def ordered(\n        self,\n        value: int,\n        prefix: str,\n        queryset: QuerySet,\n    ):\n        queryset = queryset.alias(\n          _ordered_num=Count(f\"{prefix}orders__id\")\n        )\n        return queryset, Q(**{f\"{prefix}_ordered_num\": value})\n\n    @strawberry_django.order_field\n    def filter(\n        self,\n        info: Info,\n        queryset: QuerySet,\n        prefix: str,\n    ) -&gt; tuple[QuerySet, list[Q]]:\n        queryset = queryset.filter(\n            ... # Do some query modification\n        )\n\n        return strawberry_django.process_filters(\n            self,\n            info=info,\n            queryset=queryset,\n            prefix=prefix,\n            skip_object_order_method=True\n        )\n</code></pre> <p>Tip</p> <p>As seen above <code>strawberry_django.process_filters</code> function is exposed and can be reused in custom methods. For filter method <code>filter</code> <code>skip_object_order_method</code> was used to avoid endless recursion.</p>"},{"location":"guide/filters/#adding-filters-to-types","title":"Adding filters to types","text":"<p>All fields and CUD mutations inherit filters from the underlying type by default. So, if you have a field like this:</p> types.py<pre><code>@strawberry_django.type(models.Fruit, filters=FruitFilter)\nclass Fruit:\n    ...\n\n@strawberry.type\nclass Query:\n    fruits: list[Fruit] = strawberry_django.field()\n</code></pre> <p>The <code>fruits</code> field will inherit the <code>filters</code> of the type in the same way as if it was passed to the field.</p>"},{"location":"guide/filters/#adding-filters-directly-into-a-field","title":"Adding filters directly into a field","text":"<p>Filters added into a field override the default filters of this type.</p> schema.py<pre><code>@strawberry.type\nclass Query:\n    fruits: list[Fruit] = strawberry_django.field(filters=FruitFilter)\n</code></pre>"},{"location":"guide/filters/#generic-lookup-reference","title":"Generic Lookup reference","text":"<p>There is 7 already defined Generic Lookup <code>strawberry.input</code> classes importable from <code>strawberry_django</code></p>"},{"location":"guide/filters/#basefilterlookup","title":"<code>BaseFilterLookup</code>","text":"<ul> <li>contains <code>exact</code>, <code>isNull</code> &amp; <code>inList</code></li> <li>used for <code>ID</code> &amp; <code>bool</code> fields</li> </ul>"},{"location":"guide/filters/#rangelookup","title":"<code>RangeLookup</code>","text":"<ul> <li>used for <code>range</code> or <code>BETWEEN</code> filtering</li> </ul>"},{"location":"guide/filters/#comparisonfilterlookup","title":"<code>ComparisonFilterLookup</code>","text":"<ul> <li>inherits <code>BaseFilterLookup</code></li> <li>additionaly contains <code>gt</code>, <code>gte</code>, <code>lt</code>, <code>lte</code>, &amp; <code>range</code></li> <li>used for Numberical fields</li> </ul>"},{"location":"guide/filters/#filterlookup","title":"<code>FilterLookup</code>","text":"<ul> <li>inherits <code>BaseFilterLookup</code></li> <li>additionally contains <code>iExact</code>, <code>contains</code>, <code>iContains</code>, <code>startsWith</code>, <code>iStartsWith</code>, <code>endsWith</code>, <code>iEndsWith</code>, <code>regex</code> &amp; <code>iRegex</code></li> <li>used for string based fields and as default</li> </ul>"},{"location":"guide/filters/#datefilterlookup","title":"<code>DateFilterLookup</code>","text":"<ul> <li>inherits <code>ComparisonFilterLookup</code></li> <li>additionally contains <code>year</code>,<code>month</code>,<code>day</code>,<code>weekDay</code>,<code>isoWeekDay</code>,<code>week</code>,<code>isoYear</code> &amp; <code>quarter</code></li> <li>used for date based fields</li> </ul>"},{"location":"guide/filters/#timefilterlookup","title":"<code>TimeFilterLookup</code>","text":"<ul> <li>inherits <code>ComparisonFilterLookup</code></li> <li>additionally contains <code>hour</code>,<code>minute</code>,<code>second</code>,<code>date</code> &amp; <code>time</code></li> <li>used for time based fields</li> </ul>"},{"location":"guide/filters/#datetimefilterlookup","title":"<code>DatetimeFilterLookup</code>","text":"<ul> <li>inherits <code>DateFilterLookup</code> &amp; <code>TimeFilterLookup</code></li> <li>used for timedate based fields</li> </ul>"},{"location":"guide/filters/#legacy-filtering","title":"Legacy filtering","text":"<p>The previous version of filters can be enabled via USE_DEPRECATED_FILTERS</p> <p>Warning</p> <p>If USE_DEPRECATED_FILTERS is not set to <code>True</code> legacy custom filtering methods will be not be called.</p> <p>When using legacy filters it is important to use legacy <code>strawberry_django.filters.FilterLookup</code> lookups as well. The correct version is applied for <code>auto</code> annotated filter field (given <code>lookups=True</code> being set). Mixing old and new lookups might lead to error <code>DuplicatedTypeName: Type StrFilterLookup is defined multiple times in the schema</code>.</p> <p>While legacy filtering is enabled new filtering custom methods are fully functional including default <code>filter</code> method.</p> <p>Migration process could be composed of these steps:</p> <ul> <li>enable USE_DEPRECATED_FILTERS</li> <li>gradually transform custom filter field methods to new version (do not forget to use old FilterLookup if applicable)</li> <li>gradually transform default <code>filter</code> methods</li> <li>disable USE_DEPRECATED_FILTERS - This is breaking change</li> </ul>"},{"location":"guide/mutations/","title":"Mutations","text":""},{"location":"guide/mutations/#getting-started","title":"Getting started","text":"<p>Mutations can be defined the same way as strawberry's mutations, but instead of using <code>@strawberry.mutation</code>, use <code>@strawberry_django.mutation</code>.</p> <p>Here are the differences between those:</p> <ul> <li>Strawberry Django's mutation will be sure that the mutation is executed in an async safe   environment, meaning that if you are running ASGI and you define a <code>sync</code> resolver, it will   automatically be wrapped in a <code>sync_to_async</code> call.</li> <li>It will better integrate with the permissioning integration</li> <li>It has an option to automatically handle common django errors and return them   in a standardized way (more on that below)</li> </ul>"},{"location":"guide/mutations/#django-errors-handling","title":"Django errors handling","text":"<p>When defining a mutation you can pass <code>handle_django_errors=True</code> to make it handle common django errors, such as <code>ValidationError</code>, <code>PermissionDenied</code> and <code>ObjectDoesNotExist</code>:</p> types.py<pre><code>@strawberry.type\nclass Mutation:\n    @strawberry_django.mutation(handle_django_errors=True)\n    def create_fruit(self, name: str, color: str) -&gt; Fruit:\n        if not is_valid_color(color):\n            raise ValidationError(\"The color is not valid\")\n\n        # Creation can also raise ValidationError, if the `name` is\n        # larger than its allowed `max_length` for example.\n        fruit = models.Fruit.objects.create(name=name)\n        return cast(Fruit, fruit)\n</code></pre> <p>The code above would generate following schema:</p> schema.graphql<pre><code>enum OperationMessageKind {\n  INFO\n  WARNING\n  ERROR\n  PERMISSION\n  VALIDATION\n}\n\ntype OperationInfo {\n  \"\"\"List of messages returned by the operation.\"\"\"\n  messages: [OperationMessage!]!\n}\n\ntype OperationMessage {\n  \"\"\"The kind of this message.\"\"\"\n  kind: OperationMessageKind!\n\n  \"\"\"The error message.\"\"\"\n  message: String!\n\n  \"\"\"\n  The field that caused the error, or `null` if it isn't associated with any particular field.\n  \"\"\"\n  field: String\n\n  \"\"\"The error code, or `null` if no error code was set.\"\"\"\n  code: String\n}\n\ntype Fruit {\n  name: String!\n  color: String!\n}\n\nunion CreateFruitPayload = Fruit | OperationInfo\n\nmutation {\n  createFruit(\n    name: String!\n    color: String!\n  ): CreateFruitPayload!\n}\n</code></pre> <p>Tip</p> <p>If all or most of your mutations use this behaviour, you can change the default behaviour for <code>handle_django_errors</code> by setting <code>MUTATIONS_DEFAULT_HANDLE_ERRORS=True</code>  in your strawberry django settings</p>"},{"location":"guide/mutations/#input-mutations","title":"Input mutations","text":"<p>Those are defined using <code>@strawberry_django.input_mutation</code> and act the same way as the <code>@strawberry_django.mutation</code>, the only difference being that it injects an InputMutationExtension in the field, which converts its arguments in a new type (check the extension's docs for more information).</p>"},{"location":"guide/mutations/#cud-mutations","title":"CUD mutations","text":"<p>The following CUD mutations are provided by this lib:</p> <ul> <li><code>strawberry_django.mutations.create</code>: Will create the model using the data from the given input</li> <li><code>strawberry_django.mutations.update</code>: Will update the model using the data from the given input</li> <li><code>strawberry_django.mutations.delete</code>: Will delete the model using the id from the given input</li> </ul> <p>A basic example would be:</p> types.py<pre><code>from strawberry import auto\nfrom strawberry_django import mutations, NodeInput\nfrom strawberry.relay import Node\n\n\n\n@strawberry_django.type(SomeModel)\nclass SomeModelType(Node):\n    name: auto\n\n@strawberry_django.input(SomeModel)\nclass SomeModelInput:\n    name: auto\n\n\n@strawberry_django.partial(SomeModel)\nclass SomeModelInputPartial(NodeInput):\n    name: auto\n\n@strawberry.type\nclass Mutation:\n    create_model: SomeModelType = mutations.create(SomeModelInput)\n    update_model: SomeModelType = mutations.update(SomeModelInputPartial)\n    delete_model: SomeModelType = mutations.delete(NodeInput)\n</code></pre> <p>Some things to note here:</p> <ul> <li>Those CUD mutations accept the same arguments as <code>@strawberry_django.mutation</code>   accepts. This allows you to pass <code>handle_django_errors=True</code> to it for example.</li> <li>The mutation will receive the type in an argument named <code>\"data\"</code> by default.   To change it to <code>\"info\"</code> for example, you can change it by passing   <code>argument_name=\"info\"</code> to the mutation, or set <code>MUTATIONS_DEFAULT_ARGUMENT_NAME=\"info\"</code>   in your strawberry django settings to make it the default when not provided.</li> <li>Take note that inputs using <code>partial</code> will not automatically mark non-auto fields optional   and instead will respect explicit type annotations;   see partial input types documentation for examples.</li> <li>I's also possible to update or delete model by using unique identifier other than id by providing <code>key_attr</code> property :</li> </ul> <pre><code>@strawberry_django.partial(SomeModel)\nclass SomeModelInputPartial:\n    unique_field: strawberry.auto\n\n@strawberry.type\nclass Mutation:\n    update_model: SomeModelType = mutations.update(\n        SomeModelInputPartial,\n        key_attr=\"unique_field\",\n    )\n    delete_model: SomeModelType = mutations.delete(\n        SomeModelInputPartial,\n        key_attr=\"unique_field\",\n    )\n</code></pre>"},{"location":"guide/mutations/#filtering","title":"Filtering","text":"<p>Danger</p> <p>This is totally discouraged as it allows for any issue with the filters to be able to alter your whole model collection.</p> <p>You have been warned!</p> <p>Filters can be added to update and delete mutations. More information in the filtering section.</p> schema.py<pre><code>import strawberry\nfrom strawberry_django import mutations\n\n@strawberry.type\nclass Mutation:\n    updateFruits: List[Fruit] = mutations.update(FruitPartialInput, filters=FruitFilter)\n    deleteFruits: List[Fruit] = mutations.delete(filters=FruitFilter)\n\nschema = strawberry.Schema(mutation=Mutation)\n</code></pre>"},{"location":"guide/optimizer/","title":"Query Optimizer","text":""},{"location":"guide/optimizer/#features","title":"Features","text":"<p>The query optimizer is a must-have extension for improved performance of your schema. What it does:</p> <ol> <li>Call QuerySet.select_related()    on all selected foreign key relations by the query to avoid requiring an extra query to retrieve those</li> <li>Call QuerySet.prefetch_related()    on all selected many-to-one/many-to-many relations by the query to avoid requiring an extra query to retrieve those.</li> <li>Call QuerySet.only()    on all selected fields to reduce the database payload and only requesting what is actually being    selected</li> <li>Call QuerySet.annotate()    to support any passed annotations    of Query Expressions.</li> </ol> <p>Those are specially useful to avoid some common GraphQL pitfalls, like the famous <code>n+1</code> issue.</p>"},{"location":"guide/optimizer/#enabling-the-extension","title":"Enabling the extension","text":"<p>The automatic optimization can be enabled by adding the <code>DjangoOptimizerExtension</code> to your strawberry's schema config.</p> schema.py<pre><code>import strawberry\nfrom strawberry_django.optimizer import DjangoOptimizerExtension\n\nschema = strawberry.Schema(\n    Query,\n    extensions=[\n        # other extensions...\n        DjangoOptimizerExtension,\n    ]\n)\n</code></pre>"},{"location":"guide/optimizer/#usage","title":"Usage","text":"<p>The optimizer will try to optimize all types automatically by introspecting it. Consider the following example:</p> models.py<pre><code>class Artist(models.Model):\n    name = models.CharField()\n\n\nclass Album(models.Model):\n    name = models.CharField()\n    release_date = models.DateTimeField()\n    artist = models.ForeignKey(\"Artist\", related_name=\"albums\")\n\n\nclass Song(models.Model):\n    name = model.CharField()\n    duration = models.DecimalField()\n    album = models.ForeignKey(\"Album\", related_name=\"songs\")\n</code></pre> types.py<pre><code>from strawberry import auto\nimport strawberry_django\n\n@strawberry_django.type(Artist)\nclass ArtistType:\n    name: auto\n    albums: list[\"AlbumType\"]\n    albums_count: int = strawberry_django.field(annotate=Count(\"albums\"))\n\n\n@strawberry_django.type(Album)\nclass AlbumType:\n    name: auto\n    release_date: auto\n    artist: ArtistType\n    songs: list[\"SongType\"]\n\n\n@strawberry_django.type(Song)\nclass SongType:\n    name: auto\n    duration: auto\n    album_type: AlbumType\n\n\n@strawberry.type\nclass Query:\n    artist: Artist = strawberry_django.field()\n    songs: List[SongType] = strawberry_django.field()\n</code></pre> <p>Querying for <code>artist</code> and <code>songs</code> like this:</p> schema.graphql<pre><code>query {\n  artist {\n    id\n    name\n    albums {\n      id\n      name\n      songs {\n        id\n        name\n      }\n    }\n    albumsCount\n  }\n  song {\n    id\n    album {\n      id\n      name\n      artist {\n        id\n        name\n        albums {\n          id\n          name\n          release_date\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Would produce an ORM query like this:</p> <pre><code># For \"artist\" query\nArtist.objects.all().only(\"id\", \"name\").prefetch_related(\n    Prefetch(\n        \"albums\",\n        queryset=Album.objects.all().only(\"id\", \"name\").prefetch_related(\n            Prefetch(\n               \"songs\",\n               Song.objects.all().only(\"id\", \"name\"),\n            )\n        )\n    ),\n).annotate(\n    albums_count=Count(\"albums\")\n)\n\n# For \"songs\" query\nSong.objects.all().only(\n    \"id\",\n    \"album\",\n    \"album__id\",\n    \"album__name\",\n    \"album__release_date\",  # Note about this below\n    \"album__artist\",\n    \"album__artist__id\",\n).select_related(\n    \"album\",\n    \"album__artist\",\n).prefetch_related(\n    Prefetch(\n       \"album__artist__albums\",\n        Album.objects.all().only(\"id\", \"name\", \"release_date\"),\n    )\n)\n</code></pre> <p>Note</p> <p>Even though <code>album__release_date</code> field was not selected here, it got selected in the prefetch query later. Since Django caches known objects, we have to select it here or else it would trigger extra queries latter.</p>"},{"location":"guide/optimizer/#optimization-hints","title":"Optimization hints","text":"<p>Sometimes you will have a custom resolver which cannot be automatically optimized by the extension. Take this for example:</p> models.py<pre><code>class OrderItem(models.Model):\n    price = models.DecimalField()\n    quantity = models.IntegerField()\n\n    @property\n    def total(self) -&gt; decimal.Decimal:\n        return self.price * self.quantity\n</code></pre> types.py<pre><code>from strawberry import auto\nimport strawberry_django\n\n@strawberry_django.type(models.OrderItem)\nclass OrderItem:\n    price: auto\n    quantity: auto\n    total: auto\n</code></pre> <p>In this case, if only <code>total</code> is requested it would trigger an extra query for both <code>price</code> and <code>quantity</code> because both had their value retrievals defered by the optimizer.</p> <p>A solution in this case would be to \"tell the optimizer\" how to optimize that field:</p> types.py<pre><code>from strawberry import auto\nimport strawberry_django\n\n@strawberry_django.type(models.OrderItem)\nclass OrderItem:\n    price: auto\n    quantity: auto\n    total: auto = strawberry_django.field(\n        only=[\"price\", \"quantity\"],\n    )\n</code></pre> <p>Or if you are using a custom resolver:</p> types.py<pre><code>import decimal\n\nfrom strawberry import auto\nimport strawberry_django\n\n@strawberry_django.type(models.OrderItem)\nclass OrderItem:\n    price: auto\n    quantity: auto\n\n    @strawberry_django.field(only=[\"price\", \"quantity\"])\n    def total(self, root: models.OrderItem) -&gt; decimal.Decimal:\n        return root.price * root.quantity  # or root.total directly\n</code></pre> <p>The following options are accepted for optimizer hints:</p> <ul> <li><code>only</code>: a list of fields in the same format as accepted by   QuerySet.only()</li> <li><code>select_related</code>: a list of relations to join using   QuerySet.select_related()</li> <li><code>prefetch_related</code>: a list of relations to prefetch using   QuerySet.prefetch_related().   The options here are strings or a callable in the format of <code>Callable[[Info], Prefetch]</code>   (e.g. <code>prefetch_related=[lambda info: Prefetch(...)]</code>)</li> <li><code>annotate</code>: a dict of expressions to annotate using   QuerySet.annotate().   The keys of this dict are strings,   and each value is a Query Expression   or a callable in the format of <code>Callable[[Info], BaseExpression]</code>   (e.g. <code>annotate={\"total\": lambda info: Sum(...)}</code>)</li> </ul>"},{"location":"guide/optimizer/#optimization-hints-on-model-modelproperty","title":"Optimization hints on model (ModelProperty)","text":"<p>It is also possible to include type hints directly in the models' <code>@property</code> to allow it to be resolved with <code>auto</code>, while the GraphQL schema doesn't have to worry about its internal logic.</p> <p>For that this integration provides 2 decorators that can be used:</p> <ul> <li><code>strawberry_django.model_property</code>: similar to <code>@property</code> but accepts optimization hints</li> <li><code>strawberry_django.cached_model_property</code>: similar to <code>@cached_property</code> but accepts   optimization hints</li> </ul> <p>The example in the previous section could be written using <code>@model_property</code> like this:</p> models.py<pre><code>from strawberry_django import model_property\n\nclass OrderItem(models.Model):\n    price = models.DecimalField()\n    quantity = models.IntegerField()\n\n    @model_property(only=[\"price\", \"quantity\"])\n    def total(self) -&gt; decimal.Decimal:\n        return self.price * self.quantity\n</code></pre> types.py<pre><code>from strawberry import auto\nimport strawberry_django\n\n@strawberry_django.type(models.OrderItem)\nclass OrderItem:\n    price: auto\n    quantity: auto\n    total: auto\n</code></pre> <p><code>total</code> now will be properly optimized since it points to a <code>@model_property</code> decorated attribute, which contains the required information for optimizing it.</p>"},{"location":"guide/ordering/","title":"Ordering","text":"types.py<pre><code>@strawberry_django.order(models.Color)\nclass ColorOrder:\n    name: auto\n\n@strawberry_django.order(models.Fruit)\nclass FruitOrder:\n    name: auto\n    color: ColorOrder | None\n</code></pre> <p>Tip</p> <p>In most cases order fields should have <code>Optional</code> annotations and default value <code>strawberry.UNSET</code>. Above <code>auto</code> annotation is wrapped in <code>Optional</code> automatically. <code>UNSET</code> is automatically used for fields without <code>field</code> or with <code>strawberry_django.order_field</code>.</p> <p>The code above generates the following schema:</p> schema.graphql<pre><code>enum Ordering {\n  ASC\n  ASC_NULLS_FIRST\n  ASC_NULLS_LAST\n  DESC\n  DESC_NULLS_FIRST\n  DESC_NULLS_LAST\n}\n\ninput ColorOrder {\n  name: Ordering\n}\n\ninput FruitOrder {\n  name: Ordering\n  color: ColorOrder\n}\n</code></pre>"},{"location":"guide/ordering/#custom-order-methods","title":"Custom order methods","text":"<p>You can define custom order method by defining your own resolver.</p> types.py<pre><code>@strawberry_django.order(models.Fruit)\nclass FruitOrder:\n    name: auto\n\n    @strawberry_django.order_field\n    def discovered_by(self, value: bool, prefix: str) -&gt; list[str]:\n        if not value:\n            return []\n        return [f\"{prefix}discover_by__name\", f\"{prefix}name\"]\n\n    @strawberry_django.order_field\n    def order_number(\n        self,\n        info: Info,\n        queryset: QuerySet,\n        value: strawberry_django.Ordering, # `auto` can be used instead\n        prefix: str,\n        sequence: dict[str, strawberry_django.Ordering] | None\n    ) -&gt; tuple[QuerySet, list[str]] | list[str]:\n        queryset = queryset.alias(\n            _ordered_num=Count(f\"{prefix}orders__id\")\n        )\n        ordering = value.resolve(f\"{prefix}_ordered_num\")\n        return queryset, [ordering]\n</code></pre> <p>Warning</p> <p>Do not use <code>queryset.order_by()</code> directly. Due to <code>order_by</code> not being chainable operation, changes applied this way would be overriden later.</p> <p>Tip</p> <p><code>strawberry_django.Ordering</code> has convenient method <code>resolve</code> that can be used to convert field's name to appropriate <code>F</code> object with correctly applied <code>asc()</code>, <code>desc()</code> method with <code>nulls_first</code> and <code>nulls_last</code> arguments.</p> <p>The code above generates the following schema:</p> schema.graphql<pre><code>enum Ordering {\n  ASC\n  ASC_NULLS_FIRST\n  ASC_NULLS_LAST\n  DESC\n  DESC_NULLS_FIRST\n  DESC_NULLS_LAST\n}\n\ninput FruitOrder {\n  name: Ordering\n  discoveredBy: bool\n  orderNumber: Ordering\n}\n</code></pre>"},{"location":"guide/ordering/#resolver-arguments","title":"Resolver arguments","text":"<ul> <li><code>prefix</code> - represents the current path or position</li> <li>Required</li> <li>Important for nested ordering</li> <li>In code bellow custom order <code>name</code> ends up ordering <code>Fruit</code> instead of <code>Color</code> without applying <code>prefix</code></li> </ul> Why prefix?<pre><code>@strawberry_django.order(models.Fruit)\nclass FruitOrder:\n    name: auto\n    color: ColorOrder | None\n\n@strawberry_django.order(models.Color)\nclass ColorOrder:\n    @strawberry_django.order_field\n    def name(self, value: bool, prefix: str):\n        # prefix is \"fruit_set__\" if unused root object is ordered instead\n        if value:\n            return [\"name\"]\n        return []\n</code></pre> <pre><code>{\n  fruits( order: {color: name: ASC} ) { ... }\n}\n</code></pre> <ul> <li><code>value</code> - represents graphql field type</li> <li>Required, but forbidden for default <code>order</code> method</li> <li>must be annotated</li> <li>used instead of field's return type</li> <li>Using <code>auto</code> is the same as <code>strawberry_django.Ordering</code>.</li> <li><code>queryset</code> - can be used for more complex ordering</li> <li>Optional, but Required for default <code>order</code> method</li> <li>usually used to <code>annotate</code> <code>QuerySet</code></li> <li><code>sequence</code> - used to order values on the same level</li> <li>elements in graphql object are not quaranteed to keep their order as defined by user thus     this argument should be used in those cases     GraphQL Spec</li> <li>usually for custom order field methods does not have to be used</li> <li>for advanced usage, look at <code>strawberry_django.process_order</code> function</li> </ul>"},{"location":"guide/ordering/#resolver-return","title":"Resolver return","text":"<p>For custom field methods two return values are supported</p> <ul> <li>iterable of values acceptable by <code>QuerySet.order_by</code> -&gt; <code>Collection[F | str]</code></li> <li>tuple with <code>QuerySet</code> and iterable of values acceptable by <code>QuerySet.order_by</code> -&gt; <code>tuple[QuerySet, Collection[F | str]]</code></li> </ul> <p>For default <code>order</code> method only second variant is supported.</p>"},{"location":"guide/ordering/#what-about-nulls","title":"What about nulls?","text":"<p>By default <code>null</code> values are ignored. This can be toggled as such <code>@strawberry_django.order_field(order_none=True)</code></p>"},{"location":"guide/ordering/#overriding-the-default-order-method","title":"Overriding the default <code>order</code> method","text":"<p>Works similar to field order method, but:</p> <ul> <li>is responsible for resolution of ordering for entire object</li> <li>must be named <code>order</code></li> <li>argument <code>queryset</code> is Required</li> <li>argument <code>value</code> is Forbidden</li> <li>should probaly use <code>sequence</code></li> </ul> types.py<pre><code>@strawberry_django.order(models.Fruit)\nclass FruitOrder:\n    name: auto\n\n    @strawberry_django.order_field\n    def ordered(\n        self,\n        info: Info,\n        queryset: QuerySet,\n        value: strawberry_django.Ordering,\n        prefix: str\n    ) -&gt; tuple[QuerySet, list[str]] | list[str]:\n        queryset = queryset.alias(\n          _ordered_num=Count(f\"{prefix}orders__id\")\n        )\n        return queryset, [value.resolve(f\"{prefix}_ordered_num\") ]\n\n    @strawberry_django.order_field\n    def order(\n        self,\n        info: Info,\n        queryset: QuerySet,\n        prefix: str,\n        sequence: dict[str, strawberry_django.Ordering] | None\n    ) -&gt; tuple[QuerySet, list[str]]:\n        queryset = queryset.filter(\n            ... # Do some query modification\n        )\n\n        return strawberry_django.process_order(\n            self,\n            info=info,\n            queryset=queryset,\n            sequence=sequence,\n            prefix=prefix,\n            skip_object_order_method=True\n        )\n</code></pre> <p>Tip</p> <p>As seen above <code>strawberry_django.process_order</code> function is exposed and can be reused in custom methods. For order method <code>order</code> <code>skip_object_order_method</code> was used to avoid endless recursion.</p>"},{"location":"guide/ordering/#adding-orderings-to-types","title":"Adding orderings to types","text":"<p>All fields and mutations inherit orderings from the underlying type by default. So, if you have a field like this:</p> types.py<pre><code>@strawberry_django.type(models.Fruit, order=FruitOrder)\nclass Fruit:\n    ...\n</code></pre> <p>The <code>fruits</code> field will inherit the <code>order</code> of the type same same way as if it was passed to the field.</p>"},{"location":"guide/ordering/#adding-orderings-directly-into-a-field","title":"Adding orderings directly into a field","text":"<p>Orderings added into a field override the default order of this type.</p> schema.py<pre><code>@strawberry.type\nclass Query:\n    fruit: Fruit = strawberry_django.field(order=FruitOrder)\n</code></pre>"},{"location":"guide/pagination/","title":"Pagination","text":""},{"location":"guide/pagination/#default-pagination","title":"Default pagination","text":"<p>An interface for limit/offset pagination can be use for basic pagination needs:</p> types.py<pre><code>@strawberry_django.type(models.Fruit, pagination=True)\nclass Fruit:\n    name: auto\n</code></pre> schema.graphql<pre><code>query {\n  fruits(pagination: { offset: 0, limit: 2 }) {\n    name\n    color\n  }\n}\n</code></pre> <p>There is not default limit defined. All elements are returned if no pagination limit is defined.</p>"},{"location":"guide/pagination/#relay-pagination","title":"Relay pagination","text":"<p>For more complex scenarios, a cursor pagination would be better. For this, use the relay integration to define those.</p>"},{"location":"guide/permissions/","title":"Permissions","text":"<p>This integration exposes a field extension to extend fields into using the Django's Permissioning System for checking for permissions.</p> <p>It supports protecting any field for cases like:</p> <ul> <li>The user is authenticated</li> <li>The user is a superuser</li> <li>The user or a group they belongs to has a given permission</li> <li>The user or the group they belongs has a given permission to the resolved value</li> <li>The user or the group they belongs has a given permission to the parent of the field</li> <li>etc</li> </ul>"},{"location":"guide/permissions/#how-it-works","title":"How it works","text":"<pre><code>graph TD\n  A[Extension Check for Permissions] --&gt; B;\n  B[User Passes Checks] --&gt;|Yes| BF[Return Resolved Value];\n  B --&gt;|No| C;\n  C[Can return 'OperationInfo'?] --&gt;|Yes| CF[Return 'OperationInfo'];\n  C --&gt;|No| D;\n  D[Field is Optional] --&gt;|Yes| DF[Return 'None'];\n  D --&gt;|No| E;\n  E[Field is a 'List'] --&gt;|Yes| EF[Return an empty 'List'];\n  E --&gt;|No| F;\n  F[Field is a relay `Connection`] --&gt;|Yes| FF[Return an empty relay 'Connection'];\n  F --&gt;|No| GF[Raises 'PermissionDenied' error];</code></pre>"},{"location":"guide/permissions/#example","title":"Example","text":"types.py<pre><code>import strawberry_django\nfrom strawberry_django.permissions import (\n    IsAuthenticated,\n    HasPerm,\n    HasRetvalPerm,\n)\n\n\n@strawberry_django.type\nclass SomeType:\n    login_required_field: RetType = strawberry_django.field(\n        # will check if the user is authenticated\n        extensions=[IsAuthenticated()],\n    )\n    perm_required_field: OtherType = strawberry_django.field(\n        # will check if the user has `\"some_app.some_perm\"` permission\n        extensions=[HasPerm(\"some_app.some_perm\")],\n    )\n    obj_perm_required_field: OtherType = strawberry_django.field(\n        # will check the permission for the resolved value\n        extensions=[HasRetvalPerm(\"some_app.some_perm\")],\n    )\n</code></pre>"},{"location":"guide/permissions/#available-options","title":"Available Options","text":"<p>Available options are:</p> <ul> <li><code>IsAuthenticated</code>: Checks if the user is authenticated (i.e. <code>user.is_autenticated</code>)</li> <li><code>IsStaff</code>: Checks if the user is a staff member (i.e. <code>user.is_staff</code>)</li> <li><code>IsSuperuser</code>: Checks if the user is a superuser (i.e. <code>user.is_superuser</code>)</li> <li><code>HasPerm(perms: str | list[str], any_perm: bool = True)</code>: Checks if the user has any or all of   the given permissions (i.e. <code>user.has_perm(perm)</code>)</li> <li><code>HasSourcePerm(perms: str | list[str], any: bool = True)</code>: Checks if the user has any or all   of the given permissions for the root of that field (i.e. <code>user.has_perm(perm, root)</code>)</li> <li><code>HasRetvalPerm(perms: str | list[str], any: bool = True)</code>: Resolves the retval and then   checks if the user has any or all of the given permissions for that specific value   (i.e. <code>user.has_perm(perm, retval)</code>). If the return value is a list, this extension   will filter the return value, removing objects that fails the check (check below for more   information regarding other possibilities).</li> </ul> <p>Note</p> <p>The <code>HasSourcePerm</code> and <code>HasRetvalPerm</code> require having an authentication backend which supports resolving object permissions. This lib works out of the box with django-guardian, so if you are using it you don't need to do anything else.</p>"},{"location":"guide/permissions/#no-permission-handling","title":"No Permission Handling","text":"<p>When the condition fails, the following will be returned on the field (following this priority):</p> <ol> <li><code>OperationInfo</code>/<code>OperationMessage</code> if those types are allowed at the return type</li> <li><code>null</code> in case the field is not mandatory (e.g. <code>String</code> or <code>[String]</code>)</li> <li>An empty list in case the field is a list (e.g. <code>[String]!</code>)</li> <li>An empty <code>Connection</code> in case the return type is a relay connection</li> <li>Otherwise, an error will be raised</li> </ol>"},{"location":"guide/permissions/#custom-permissions-checking","title":"Custom Permissions Checking","text":"<p>You can create your own permission checking extension by subclassing <code>DjangoPermissionExtension</code> and implementing your own <code>resolve_for_user</code> method.</p>"},{"location":"guide/queries/","title":"Queries","text":"<p>Queries can be written using <code>strawberry_django.field()</code> to load the fields defined in the <code>types.py</code> file.</p> <pre><code>#schema.py\n\nimport strawberry\nimport strawberry_django\n\nfrom .types import Fruit\n\n@strawberry.type\nclass Query:\n\n    fruit: Fruit = strawberry_django.field()\n    fruits: list[Fruit] = strawberry_django.field()\n\nschema = strawberry.Schema(query=Query)\n</code></pre> <p>Tip</p> <p>You must name your query class \"Query\" or decorate it with <code>@strawberry.type(name=\"Query\")</code> for the single query default primary filter to work</p> <p>For the single queries (like <code>Fruit</code> above), Strawberry comes with a default primary key search filter in the GraphiQL interface. The query <code>Fruits</code> gets all the objects in the Fruits by default. To query specific sets of objects a filter need to be added in the <code>types.py</code> file.</p>"},{"location":"guide/relay/","title":"Relay Support","text":"<p>You can use the official strawberry relay integration directly with django types like this:</p> types.py<pre><code>import strawberry\nimport strawberry_django\nfrom strawberry_django.relay import ListConnectionWithTotalCount\n\n\nclass Fruit(models.Model):\n    ...\n\n\n@strawberry_django.type(Fruit)\nclass FruitType(relay.Node):\n    ...\n\n\n@strawberry.type\nclass Query:\n    # Option 1: Default relay without totalCount\n    # This is the default strawberry relay behaviour.\n    # NOTE: you need to use strawberry_django.connection() - not the default strawberry.relay.connection()\n    fruit: strawberry.relay.ListConnection[FruitType] = strawberry_django.connection()\n\n    # Option 2: Strawberry django also comes with ListConnectionWithTotalCount\n    # this will allow you to get total-count on your query.\n    fruit_with_total_count: ListConnectionWithTotalCount[\n        FruitType\n    ] = strawberry_django.connection()\n\n    # Option 3: You can manually create resolver by your method manually.\n    @strawberry_django.connection(ListConnectionWithTotalCount[FruitType])\n    def fruit_with_custom_resolver(self) -&gt; List[SomeModel]:\n        return Fruit.objects.all()\n</code></pre> <p>Behind the scenes this extension is doing the following for you:</p> <ul> <li>Automatically resolve the <code>relay.NodeID</code> field using the model's pk</li> <li>Automatically generate resolves for connections that doesn't define one. For example,   <code>some_model_conn</code> and <code>some_model_conn_with_total_count</code> will both define a custom resolver   automatically that returns <code>SomeModel.objects.all()</code>.</li> <li>Integrate connection resolution with all other features available in this lib. For example,   filters, ordering and   permissions can be used together with connections defined   by strawberry django.</li> </ul> <p>You can also define your own <code>relay.NodeID</code> field and your resolve, in the same way as <code>some_model_conn_with_resolver</code> is doing. In those cases, they will not be overridden.</p> <p>Tip</p> <p>If you are only working with types inheriting from <code>relay.Node</code> and <code>GlobalID</code> for identifying objects, you might want to set <code>MAP_AUTO_ID_AS_GLOBAL_ID=True</code> in your strawberry django settings to make sure <code>auto</code> fields gets mapped to <code>GlobalID</code> on types and filters.</p> <p>Also, this lib exposes a <code>strawberry_django.relay.ListConnectionWithTotalCount</code>, which works the same way as <code>strawberry.relay.ListConnection</code> does, but also exposes a <code>totalCount</code> attribute in the connection.</p> <p>For more customization options, like changing the pagination algorithm, adding extra fields to the <code>Connection</code>/<code>Edge</code> type, take a look at the official strawberry relay integration as those are properly explained there.</p>"},{"location":"guide/resolvers/","title":"Custom Resolvers","text":"<p>Basic resolvers are generated automatically once the types are declared.</p> <p>However it is possible to override them with custom resolvers.</p>"},{"location":"guide/resolvers/#sync-resolvers","title":"Sync resolvers","text":"<p>Sync resolvers can be used in both ASGI/WSGI and will be automatically wrapped in <code>sync_to_async</code> when running async.</p> types.py<pre><code>import strawberry_django\nfrom strawberry import auto\nfrom typing import List\nfrom . import models\n\n@strawberry_django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n\n    @strawberry_django.field\n    def fruits(self) -&gt; List[Fruit]:\n        return self.fruits.objects.filter(...)\n</code></pre>"},{"location":"guide/resolvers/#async-resolvers","title":"Async resolvers","text":"<p>Async resolvers can be used when running using ASGI.</p> types.py<pre><code>import strawberry_django\nfrom strawberry import auto\nfrom typing import List\nfrom . import models\nfrom asgiref.sync import sync_to_async\n\n@strawberry_django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n\n    @strawberry_django.field\n    async def fruits(self) -&gt; List[Fruit]:\n        return sync_to_async(list)(self.fruits.objects.filter(...))\n</code></pre>"},{"location":"guide/resolvers/#optimizing-resolvers","title":"Optimizing resolvers","text":"<p>When using custom resolvers together with the Query Optimizer Extension you might need to give it a \"hint\" on how to optimize that field</p> <p>Take a look at the optimization hints docs for more information about this topic.</p>"},{"location":"guide/resolvers/#issues-with-resolvers","title":"Issues with Resolvers","text":"<p>It is important to note that overriding resolvers also removes default capabilities (e.g. <code>Pagination</code>, <code>Filter</code>), exception for relay connections. You can however still add those by hand and resolve them:</p> types.py<pre><code>import strawberry\nfrom strawberry import auto\nfrom strawberry.types import Info\nimport strawberry_django\nfrom . import models\n\n\n@strawberry_django.filter(models.Fruit, lookups=True)\nclass FruitFilter:\n    id: auto\n    name: auto\n\n\n@strawberry_django.type(models.Fruit, order=FruitOrder)\nclass Fruit:\n    id: auto\n    name: auto\n\n\n@strawberry_django.type(models.Fruit, is_interface=True)\nclass Fruit:\n    id: auto\n    name: auto\n\n\n@strawberry.type\nclass Query:\n    @strawberry_django.field\n    def fruits(\n        self,\n        filters: FruitFilter | None = strawberry.UNSET,\n        order: FruitOrder | None = strawberry.UNSET,\n        info: Info\n    ) -&gt; list[Fruit]\n        qs = models.fruit.objects.all()\n\n        # apply filters if defined\n        if filters is not strawberry.UNSET:\n            qs = strawberry_django.filters.apply(filters, qs, info)\n\n        # apply ordering if defined\n        if order is not strawberry.UNSET:\n            qs = strawberry_django.ordering.apply(filters, qs)\n\n        return qs\n</code></pre>"},{"location":"guide/settings/","title":"Django Settings","text":"<p>Certain features of this library are configured using custom Django settings.</p>"},{"location":"guide/settings/#strawberry_django","title":"STRAWBERRY_DJANGO","text":"<p>A dictionary with the following optional keys:</p> <ul> <li> <p><code>FIELD_DESCRIPTION_FROM_HELP_TEXT</code> (default: <code>False</code>)</p> <p>If True, GraphQL field's description   will be fetched from the corresponding Django model field's   <code>help_text</code> attribute.   If a description is provided using field customization,   that description will be used instead.</p> </li> <li> <p><code>TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING</code> (default: <code>False</code>)</p> <p>If True, GraphQL type descriptions   will be fetched from the corresponding Django model's   docstring.   If a description is provided using the   <code>strawberry_django.type</code> decorator,   that description will be used instead.</p> </li> <li> <p><code>MUTATIONS_DEFAULT_ARGUMENT_NAME</code> (default: <code>\"data\"</code>)</p> <p>Change the CUD mutations' default   argument name when no option is passed (e.g. to <code>\"input\"</code>)</p> </li> <li> <p><code>MUTATIONS_DEFAULT_HANDLE_ERRORS</code> (default: <code>False</code>)</p> <p>Set the default behaviour of the   Django Errors Handling   when no option is passed.</p> </li> <li> <p><code>GENERATE_ENUMS_FROM_CHOICES</code> (default: <code>False</code>)</p> <p>If True, fields with <code>choices</code> will have automatically generate   an enum of possibilities instead of being exposed as <code>String</code>.   A better option is to use   Django's TextChoices/IntegerChoices   with the django-choices-field integration.</p> </li> <li> <p><code>MAP_AUTO_ID_AS_GLOBAL_ID</code> (default: <code>False</code>)</p> <p>If True, <code>auto</code> fields that refer to model ids will be mapped to <code>relay.GlobalID</code>   instead of <code>strawberry.ID</code>. This is mostly useful if all your model types inherit   from <code>relay.Node</code> and you want to work only with <code>GlobalID</code>.</p> </li> <li> <p><code>DEFAULT_PK_FIELD_NAME</code> (default: <code>\"pk\"</code>)</p> <p>Change the CRUD mutations' default   primary key field.</p> </li> <li> <p><code>USE_DEPRECATED_FILTERS</code> (default: <code>False</code>)</p> <p>If True, legacy filters are enabled. This is usefull for migrating from previous version.</p> </li> </ul> <p>These features can be enabled by adding this code to your <code>settings.py</code> file.</p> settings.py<pre><code>STRAWBERRY_DJANGO = {\n    \"FIELD_DESCRIPTION_FROM_HELP_TEXT\": True,\n    \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\": True,\n    \"MUTATIONS_DEFAULT_ARGUMENT_NAME\": \"input\",\n    \"MUTATIONS_DEFAULT_HANDLE_ERRORS\": True,\n    \"GENERATE_ENUMS_FROM_CHOICES\": False,\n    \"MAP_AUTO_ID_AS_GLOBAL_ID\": True,\n    \"DEFAULT_PK_FIELD_NAME\": \"id\",\n}\n</code></pre>"},{"location":"guide/subscriptions/","title":"Subscriptions","text":"<p>Subscriptions are supported using the Strawberry Django Channels integration.</p> <p>This guide will give you a minimal working example to get you going. There are 3 parts to this guide:</p> <ol> <li>Making Django compatible</li> <li>Setup local testing</li> <li>Creating your first subscription</li> </ol>"},{"location":"guide/subscriptions/#making-django-compatible","title":"Making Django compatible","text":"<p>It's important to realise that Django doesn't support websockets out of the box. To resolve this, we can help the platform along a little.</p> <p>This implementation is based on Django Channels - this means that should you wish - there is a lot more websockets fun to be had. If you're interested, head over to Django Channels.</p> <p>To add the base compatibility, go to your <code>MyProject.asgi.py</code> file and replace it with the following content. Ensure that you replace the relevant code with your setup.</p> <pre><code># MyProject.asgi.py\nimport os\n\nfrom django.core.asgi import get_asgi_application\nfrom strawberry_django.routers import AuthGraphQLProtocolTypeRouter\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"MyProject.settings\")  # CHANGE the project name\ndjango_asgi_app = get_asgi_application()\n\n# Import your Strawberry schema after creating the django ASGI application\n# This ensures django.setup() has been called before any ORM models are imported\n# for the schema.\n\nfrom .schema import schema  # CHANGE path to where you housed your schema file.\napplication = AuthGraphQLProtocolTypeRouter(\n    schema,\n    django_application=django_asgi_app,\n)\n</code></pre> <p>Also, ensure that you enable subscriptions on your AsgiGraphQLView in <code>MyProject.urls.py</code>:</p> <pre><code>...\n\nurlpatterns = [\n    ...\n    path(\n        'graphql/',\n        AsyncGraphQLView.as_view(\n            schema=schema,\n            graphiql=settings.DEBUG,\n            subscriptions_enabled=True,\n        ),\n    ),\n    ...\n]\n</code></pre> <p>Note, django-channels allows for a lot more complexity. Here we merely cover the basic framework to get subscriptions to run on Django with minimal effort. Should you be interested in discovering the far more advanced capabilities of Dango channels, head over to channels docs</p>"},{"location":"guide/subscriptions/#setup-local-testing","title":"Setup local testing","text":"<p>The classic <code>./manage.py runserver</code> will not support subscriptions as it runs on WSGI mode. However, Django has ASGI server support out of the box through Daphne, which will override the runserver command to support our desired ASGI support.</p> <p>There are other asgi servers available, such as Uvicorn and Hypercorn. For the sake of simplicity we'll use Daphne as it comes with the runserver override. Django Docs This shouldn't stop you from using any of the other ASGI flavours in production or local testing like Uvicorn or Hypercorn</p> <p>To get started: Firstly, we need install Daphne to handle the workload, so let's install it:</p> <pre><code>pip install daphne\n</code></pre> <p>Secondly, we need to add <code>daphne</code> to your settings.py file before 'django.contrib.staticfiles'</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'daphne',\n    'django.contrib.staticfiles',\n    ...\n]\n</code></pre> <p>and add your <code>ASGI_APPLICATION</code> setting in your settings.py</p> <pre><code># settings.py\n...\nASGI_APPLICATION = 'MyProject.asgi.application'\n...\n</code></pre> <p>Now you can run your test-server like as usual, but with ASGI support:</p> <pre><code>./manage.py runserver\n</code></pre>"},{"location":"guide/subscriptions/#creating-your-first-subscription","title":"Creating your first subscription","text":"<p>Once you've taken care of those 2 setup steps, your first subscription is a breeze. Go and edit your schema-file and add:</p> <pre><code>import asyncio\nimport strawberry\n\n@strawberry.type\nclass Subscription:\n    @strawberry.subscription\n    async def count(self, target: int = 100) -&gt; int:\n        for i in range(target):\n            yield i\n            await asyncio.sleep(0.5)\n</code></pre> <p>That's pretty much it for this basic start. See for yourself by running your test server <code>./manange.py runserver</code> and opening <code>http://127.0.0.1:8000/graphql/</code> in your browser. Now run:</p> <pre><code>subscription {\n  count(target: 10)\n}\n</code></pre> <p>You should see something like (where the count changes every .5s to a max of 9)</p> <pre><code>{\n  \"data\": {\n    \"count\": 9\n  }\n}\n</code></pre>"},{"location":"guide/types/","title":"Defining Types","text":""},{"location":"guide/types/#output-types","title":"Output types","text":"<p>Note</p> <p>It is highly recommended to enable the Query Optimizer Extension for improved performance and avoid some common pitfalls (e.g. the <code>n+1</code> issue)</p> <p>Output types are generated from models. The <code>auto</code> type is used for field type auto resolution. Relational fields are described by referencing to other types generated from Django models. A many-to-many relation is described with the <code>typing.List</code> type annotation. <code>strawberry_django</code> will automatically generate resolvers for relational fields. More information about that can be read from resolvers page.</p> types.py<pre><code>import strawberry_django\n\nfrom strawberry import auto\nfrom typing import List\n\n@strawberry_django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    color: \"Color\"\n\n@strawberry_django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: List[Fruit]\n</code></pre>"},{"location":"guide/types/#input-types","title":"Input types","text":"<p>Input types can be generated from Django models using the <code>strawberry_django.input</code> decorator. The first parameter is the model which the type is derived from.</p> types.py<pre><code>@strawberry_django.input(models.Fruit)\nclass FruitInput:\n    id: auto\n    name: auto\n    color: \"ColorInput\"\n</code></pre> <p>A partial input type, in which all <code>auto</code>-typed fields are optional, is generated by setting the <code>partial</code> keyword argument in <code>input</code> to <code>True</code>. Partial input types can be generated from existing input types through class inheritance.</p> <p>Non-<code>auto</code> type annotations will be respected\u2014and therefore required\u2014unless explicitly marked <code>Optional[]</code>.</p> types.py<pre><code>@strawberry_django.input(models.Color, partial=True)\nclass FruitPartialInput(FruitInput):\n    color: List[\"ColorPartialInput\"]\n\n# Auto fields are optional\n@strawberry_django.input(models.Color, partial=True)\nclass ColorPartialInput:\n    id: auto\n    name: auto\n    fruits: List[FruitPartialInput]\n\n# Alternate input; \"name\" field will be required\n@strawberry_django.input(models.Color, partial=True)\nclass ColorNameRequiredPartialInput:\n    id: auto\n    name: str\n    fruits: List[FruitPartialInput]\n</code></pre>"},{"location":"guide/types/#types-from-django-models","title":"Types from Django models","text":"<p>Django models can be converted to <code>strawberry</code> Types with the <code>strawberry_django.type</code> decorator. Custom descriptions can be added using the <code>description</code> keyword argument (See: <code>strawberry.type</code> decorator API).</p> types.py<pre><code>import strawberry_django\n\n@strawberry_django.type(models.Fruit, description=\"A tasty snack\")\nclass Fruit:\n    ...\n</code></pre>"},{"location":"guide/types/#adding-fields-to-the-type","title":"Adding fields to the type","text":"<p>By default, no fields are implemented on the new type. Check the documentation on How to define Fields for that.</p>"},{"location":"guide/types/#customizing-the-returned-queryset","title":"Customizing the returned <code>QuerySet</code>","text":"<p>Warning</p> <p>By doing this you are modifying all automatic <code>QuerySet</code> generation for any field that returns this type. Ideally you will want to define your own resolver instead, which gives you more control over it.</p> <p>By default, a <code>strawberry_django</code> type will get data from the default manager for its Django Model. You can implement a custom <code>get_queryset</code> classmethod to your type to do some extra processing to the default queryset, like filtering it further.</p> types.py<pre><code>@strawberry_django.type(models.Fruit)\nclass Berry:\n\n    @classmethod\n    def get_queryset(cls, queryset, info, **kwargs):\n        return queryset.filter(name__contains=\"berry\")\n</code></pre> <p>The <code>get_queryset</code> classmethod is given a <code>QuerySet</code> to filter and a <code>strawberry</code> <code>Info</code> object containing details about the request.</p> <p>You can use that <code>info</code> parameter to, for example, limit access to results based on the current user in the request:</p> types.py<pre><code>from stawberry_django.auth.utils import get_current_user\n\n@strawberry_django.type(models.Fruit)\nclass Berry:\n\n    @classmethod\n    def get_queryset(cls, queryset, info, **kwargs):\n        user = get_current_user(info)\n        if not user.is_staff:\n            # Restrict access to top secret berries if the user is not a staff member\n            queryset = queryset.filter(is_top_secret=False)\n        return queryset.filter(name__contains=\"berry\")\n</code></pre> <p>Note</p> <p>Another way of limiting this is by using the PermissionExtension provided by this lib.</p> <p>The <code>kwargs</code> dictionary can include other parameters that were added in a <code>@strawberry.django.type</code> definition like filters or pagination.</p>"},{"location":"guide/unit-testing/","title":"Unit testing","text":"<p>Unit testing can be done by following the strawberry's testing docs reference.</p> <p>This lib also provides a <code>TestClient</code> and an <code>AsyncTestClient</code> that makes it easier to run tests by mimicing a call to your API.</p> <p>For example, suppose you have a <code>me</code> query which returns the currently logged in user or <code>None</code> in case it is not authenticated. You could test it like this:</p> <pre><code>from strawberry_django.test.client import TestClient\n\n\ndef test_me_unauthenticated(db):\n    client = TestClient(\"/graphql\")\n    res = client.query(\"\"\"\n      query TestQuery {\n        me {\n          pk\n          email\n          firstName\n          lastName\n        }\n      }\n    \"\"\")\n    assert res.errors is None\n    assert res.data == {\"me\": None}\n\n\ndef test_me_authenticated(db):\n    user = User.objects.create(...)\n    client = TestClient(\"/graphql\")\n\n    with client.login(user):\n        res = client.query(\"\"\"\n          query TestQuery {\n            me {\n              pk\n              email\n              firstName\n              lastName\n            }\n          }\n        \"\"\")\n\n    assert res.errors is None\n    assert res.data == {\n        \"me\": {\n            \"pk\": user.pk,\n            \"email\": user.email,\n            \"firstName\": user.first_name,\n            \"lastName\": user.last_name,\n        },\n    }\n</code></pre> <p>For more information how to apply these tests, take a look at the (source)[https://github.com/strawberry-graphql/strawberry-django/blob/main/strawberry_django/test/client.py] and (this example)[https://github.com/strawberry-graphql/strawberry-django/blob/main/tests/test_permissions.py#L49]</p>"},{"location":"guide/views/","title":"Serving the API","text":"<p>Strawberry works both with ASGI (async) and WSGI (sync). This integration supports both ways of serving django.</p> <p>ASGI is the best way to enjoy everything that strawberry has to offer and is highly recommended unless you can't for some reason. By using WSGI you will be missing support for some interesting features, such as Data Loaders.</p>"},{"location":"guide/views/#serving-as-asgi-async","title":"Serving as ASGI (async)","text":"<p>Expose the strawberry API when using ASGI by setting your urls.py like this:</p> urls.py<pre><code>from django.urls import path\nfrom strawberry.django.views import AsyncGraphQLView\n\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', AsyncGraphQLView.as_view(schema=schema)),\n]\n</code></pre>"},{"location":"guide/views/#serving-wsgi-sync","title":"Serving WSGI (sync)","text":"<p>Expose the strawberry API when using WSGI by setting your urls.py like this:</p> urls.py<pre><code>from django.urls import path\nfrom strawberry.django.views import GraphQLView\n\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', GraphQLView.as_view(schema=schema)),\n]\n</code></pre>"},{"location":"integrations/channels/","title":"django-channels","text":"<p>Strawberry provides an integration for django-channels to allow subscriptions to be used with django.</p> <p>Check the official strawberry django docs for more information on how to use it.</p>"},{"location":"integrations/choices-field/","title":"django-choices-field","text":"<p>This lib provides integration for enum resolution for Django's TextChoices/IntegerChoices when defining the fields using the django-choices-field lib:</p> models.py<pre><code>from django.db import models\nfrom django_choices_field import TextChoicesField\n\nclass Status(models.TextChoices):\n    ACTIVE = \"active\", \"Is Active\"\n    INACTIVE = \"inactive\", \"Inactive\"\n\nclass Company(models.Model):\n    status = TextChoicesField(\n        choices_enum=Status,\n        default=Status.ACTIVE,\n    )\n</code></pre> types.py<pre><code>import strawberry\nimport strawberry_django\n\nimport .models\n\n@strawberry_django.type(models.Company)\nclass Company:\n    status: strawberry.auto\n</code></pre> <p>The code above would generate the following schema:</p> schema.graphql<pre><code>enum Status {\n  ACTIVE\n  INACTIVE\n}\n\ntype Company {\n  status: Status\n}\n</code></pre>"},{"location":"integrations/debug-toolbar/","title":"django-debug-toolbar","text":"<p>This integration provides integration between the Django Debug Toolbar and <code>strawberry</code>, allowing it to display stats like <code>SQL Queries</code>, <code>CPU Time</code>, <code>Cache Hits</code>, etc for queries and mutations done inside the graphiql page.</p> <p>To use it, make sure you have the Django Debug Toolbar installed and configured, then change its middleware settings from:</p> settings.py<pre><code>MIDDLEWARE = [\n    ...\n    \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>To:</p> settings.py<pre><code>MIDDLEWARE = [\n    ...\n    \"strawberry_django.middlewares.debug_toolbar.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>Finally, ensure app <code>\"strawberry_django\"</code> is added to your <code>INSTALLED_APPS</code> in Django settings.</p>"},{"location":"integrations/guardian/","title":"django-guardian","text":"<p>This lib provides integration for per-object-permissions using django-guardian.</p> <p>Check the Permission Extension Guide for more information on how to use it.</p>"}]}