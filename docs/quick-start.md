# Quick Start

This library provides a toolset for GraphQL schema generation from Django models.

## Installing the package

```sh
pip install strawberry_graphql_django
```

The following optional dependencies are recommended to make the most of this integration:

- [django-choices-field](https://github.com/bellini666/django-choices-field)
- [django-guardian](https://django-guardian.readthedocs.io/)
- [django-debug-toolbar](https://django-debug-toolbar.readthedocs.io/)

## Sample project

Your boss asks you for a Django model called `Fruit`, which has two attributes, name and color.

```{.python title=models.py}
from django.db import models

class Fruit(models.Model):
    name = models.CharField(max_length=20)
    color = models.CharField(max_length=20)
```

Soon after that, your boss asks you to implement an API for that model so that everyone can access our great fruit database from all over the world.

The `Fruit` model has name and color attributes and we want to publish both of them. The GraphQL output type for our model is generated by using the `strawberry_django.type` decorator. Both fields are char fields so we will need to use the built-in Python `str` type in our API.

```{.python title=types.py}
import strawberry_django

from . import models

@strawberry_django.type(models.Fruit)
class Fruit:
    name: str
    color: str
```

The last step is to generate the `Query` type and the `Schema`, which we can do using the core package `strawberry`.

```{.python title=schema.py}
import strawberry
from strawberry_django.optimizer import DjangoOptimizerExtension

from .types import Fruit

@strawberry.type
class Query:
    fruits: list[Fruit] = strawberry.django.field()

schema = strawberry.Schema(
    query=Query,
    extensions=[
        DjangoOptimizerExtension,  # not required, but highly recommended
    ],
)
```

Finally we add a `AsyncGraphQLView` view to our list of urls so that we can start making our first queries.

```{.python title=urls.py}
from django.urls import include, path
from strawberry.django.views import AsyncGraphQLView

from .schema import schema

urlpatterns = [
    path('graphql', AsyncGraphQLView.as_view(schema=schema)),
]
```

After that, once the development server is running, you can read your fruits from the database through a GraphQL request.

```{.graphql title=query}
query {
  fruits {
    name
    color
  }
}
```

And it would be returned like:

```{.json title=response}
{
  fruits: [
    {
      name: "strawberry",
      color: "red"
    }
  ]
}
```

## Model Relations

Your boss wants the models to be more scalable. In particular, they think encoding `color` as a string is too limiting.
Let's create another model called `Color` and add a foreign key relation between the `Fruit` and `Color` models.

```{.python title=models.py}
from django.db import models
from django_choices_field import TextChoicesField

class FruitCategory(models.TextChoices):
    CITRUS = "citrus", "Citrus"
    BERRY = "berry", "Berry"

class Fruit(models.Model):
    name = models.CharField(
        max_length=20,
    )
    category = TextChoicesField(
        choices_enum=FruitCategory,
    )
    color = models.ForeignKey(
        "Color",
        related_name='fruits',
        on_delete=models.CASCADE,
    )

class Color(models.Model):
    name = models.CharField(max_length=20)
```

We also need to add a GraphQL Type for `Color` and modify the existing `Fruit` type to reflect our changes.
The `auto` field type is used for automatic type resolution. `strawberry_django` goes through all fields and resolves field types. It also generates resolvers for relation fields for you.

```{.python title=types.py}
import strawberry_django
from strawberry import auto

from . import models

@strawberry_django.type(models.Fruit)
class Fruit:
    id: auto
    name: auto
    category: auto
    color: "Color"

@strawberry_django.type(models.Color)
class Color:
    id: auto
    name: auto
    fruits: list[Fruit]
```

This generates the following schema:

```{.graphql title=schema.graphql}
enum FruitCategory {
  CITRUS
  BERRY
}

type Color {
  id: ID!
  name: String!
  fruits: [Fruit!]
}

type Fruit {
  id: ID!
  name: String!
  category: FruitCategory
  color: Color!
}

type Query {
  fruits: [Fruit!]!
}
```

Now you can start making queries and request all fruits and their colors from the database.

```{.graphql title=query}
query {
  fruits {
    name
    category
    color {
      name
    }
  }
}
```

The response would come like this:

```{.json title=response}
{
  fruits: [
    {
      name: "strawberry",
      category: "BERRY",
      color: { name: "red" }
    },
    {
      name: "banana",
      category: "BERRY",
      color: { name: "yellow" }
    }
  ]
}
```

## Next steps

1. [Defining more Django Types](/guide/types)
2. [Define Fields inside those Types](/guide/fields)
3. [Serve your API using ASGI or WSGI](/guide/views)
4. [Define filters for your fields](/guide/filters)
5. [Define orderings for your fields](/guide/ordering)
6. [Define pagination for your fields](/guide/pagination)
7. [Define queries for your schema](/guide/queries)
8. [Define mutations for your schema](/guide/mutations)
9. [Define subscriptions for your schema](/guide/subscriptions)
10. [Enable the Query Optimizer extension for performance improvement](/guide/optimizer)
11. [Use the relay integration for advanced pagination and model refetching](/guide/relay)
12. [Protect your fields using the Permission Extension](/guide/permissions)
13. [Write unit tests for your schema](/guide/unit-testing)
