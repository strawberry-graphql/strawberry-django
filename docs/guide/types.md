# Defining Types

## Output types

!!! note

    It is highly recommended to enable the [Query Optimizer Extension](/guide/optimizer)
    for improved performance and avoid some common pitfalls (e.g. the `n+1` issue)

Output types are generated from models. The `auto` type is used for field type auto resolution.
Relational fields are described by referencing to other types generated from Django models.
A many-to-many relation is described with the `typing.List` type annotation.
`strawberry.django` will automatically generate resolvers for relational fields.
More information about that can be read from [resolvers](resolvers.md) page.

```{.python title=types.py}
from strawberry import auto
from typing import List

@strawberry.django.type(models.Fruit)
class Fruit:
    id: auto
    name: auto
    color: "Color"

@strawberry.django.type(models.Color)
class Color:
    id: auto
    name: auto
    fruits: List[Fruit]
```

## Input types

Input types can be generated from Django models using the `strawberry.django.input` decorator.
The first parameter is the model which the type is derived from.

```{.python title=types.py}
@strawberry.django.input(models.Fruit)
class FruitInput:
    id: auto
    name: auto
    color: "ColorInput"
```

A partial input type, in which all fields are optional, is generated by setting the `partial` keyword argument in `input` to `True`.
Partial input types can be generated from existing input types through class inheritance.

```{.python title=types.py}
@strawberry.django.input(models.Color, partial=True)
class FruitPartialInput(FruitInput):
    color: List["ColorPartialInput"]

@strawberry.django.input(models.Color, partial=True)
class ColorPartialInput:
    id: auto
    name: auto
    fruits: List[FruitPartialInput]
```

## Types from Django models

Django models can be converted to `strawberry` Types with the `strawberry_django.type` decorator. Custom descriptions can be added using the `description` keyword argument (See: [`strawberry.type` decorator API](https://strawberry.rocks/docs/types/object-types#api)).

```{.python title=types.py}
import strawberry

@strawberry.django.type(models.Fruit, description="A tasty snack")
class Fruit:
    ...
```

### Adding fields to the type

By default, no fields are implemented on the new type. Check the documentation
on [How to define Fields](fields.md) for that.

### Customizing the returned `QuerySet`

!!! warning

    By doing this you are modifying all automatic `QuerySet` generation for any field
    that returns this type. Ideally you will want to define your own [resolver](resolvers.md)
    instead, which gives you more control over it.

By default, a `strawberry_django` type will get data from the default manager for its Django Model.
You can implement a custom `get_queryset` classmethod to your type to do some extra processing to the default queryset,
like filtering it further.

```{.python title=types.py}
@strawberry.django.type(models.Fruit)
class Berry:

    @classmethod
    def get_queryset(cls, queryset, info):
        return queryset.filter(name__contains="berry")
```

The `get_queryset` classmethod is given a `QuerySet` to filter and
a `strawberry` `Info` object containing details about the request.

You can use that `info` parameter to, for example,
limit access to results based on the current user in the request:

```{.python title=types.py}
@strawberry.django.type(models.Fruit)
class Berry:

    @classmethod
    def get_queryset(cls, queryset, info, **kwargs):
        if not info.context.request.user.is_staff:
            # Restrict access to top secret berries if the user is not a staff member
            queryset = queryset.filter(is_top_secret=False)
        return queryset.filter(name__contains="berry")
```

!!! note

    Another way of limiting this is by using the [PermissionExtension](permissions.md)
    provided by this lib.

The `kwargs` dictionary can include other parameters that were added in a `@strawberry.django.type` definition
like [filters](filters.md) or [pagination](pagination.md).
